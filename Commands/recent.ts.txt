import { SlashCommandBuilder, AttachmentBuilder } from "discord.js";
import { mwGetUserEntry } from "../Middleware/UserEntry";
import Canvas from "canvas";
import type { Command } from "../Structures";
import { CommandCategories, EmbedError, GraphQLRequest, SeriesTitle, getOptions } from "../Utils";
import type { MediaList, MediaType } from "../GraphQL/types";

const name = "recent";
const usage = "recent";
const description = "Shows the 9 most recent watched/read media of the user in a image grid.";

export default {
  name,
  usage,
  description,
  middlewares: [mwGetUserEntry],
  commandType: CommandCategories.Anilist,
  withBuilder: new SlashCommandBuilder()
    .setName(name)
    .setDescription(description)
    .addStringOption((option) => option.setName("type").setDescription("The type of media to search for").addChoices({ name: "Anime", value: "ANIME" }, { name: "Manga", value: "MANGA" }).setRequired(true))
    .addStringOption((option) => option.setName("user").setDescription("The user to search for").setRequired(false)),

  run: async ({ interaction, client }): Promise<void> => {
    if (!interaction.isCommand()) return;

    const { user: userName } = getOptions<{ user: string }>(interaction.options, ["user"]);
    const { type } = getOptions<{ type: MediaType }>(interaction.options, ["type"]);

    const vars: Partial<{
      perPage: number;
      type: MediaType;
      userId: number;
      user?: string;
    }> = {
      perPage: 9,
      type: type,
    };

    if (!userName) {
      // We try to use the one the user set
      try {
        vars.userId = interaction.alID;
      } catch (error) {
        console.error(error);
        return void interaction.reply({ embeds: [EmbedError(`You have yet to set an AniList token.`)] });
      }
    } else {
      vars.user = userName;
    }

    try {
      const gqlRes = await GraphQLRequest("RecentChart", vars);
      const data = gqlRes.data?.Page?.mediaList;

      if (!data) return void interaction.reply({ embeds: [EmbedError("Unable to find specified user", vars)] });

      const canvas = Canvas.createCanvas(1000, 1000);
      const ctx = canvas.getContext("2d");

      let x = 0;
      let y = 0;

      for (let item of data) {
        const media = item?.media;
        if (!media || !item) continue;
        const cover = media.coverImage?.extraLarge || "https://i.imgur.com/Hx8474m.png"; // Placeholder image
        const canvasImage = await Canvas.loadImage(cover);

        const width = 1000 / Math.ceil(data.length / 3);
        const height = (width / canvasImage.width) * canvasImage.height;

        ctx.drawImage(canvasImage, x, y, width, height);

        ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
        ctx.fillRect(x, y + width - 40, width, 40);

        ctx.font = "17px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        const title = SeriesTitle(media.title || undefined);
        const status = parseStatus(item, type);
        if (status) ctx.fillText(status, x + width / 2, y + width - 24);
        ctx.fillText(title, x + width / 2, y + width - 5);
        x += width;
        if (x >= 999) {
          x = 0;
          y += width;
        }
      }

      const canvasResult = canvas.toBuffer();
      if (!canvasResult) return void interaction.reply({ embeds: [EmbedError("Encountered an error whilst trying to create the image.", vars)] });
      const attachment = new AttachmentBuilder(canvasResult);
      interaction.reply({ files: [attachment] });
    } catch (error: any) {
      interaction.reply({ embeds: [EmbedError(error, vars)] });
    }
  },
} satisfies Command;

function parseStatus(data: MediaList, mediaType: MediaType) {
  if (!data.status) return "Unknown";
  switch (data.status) {
    case "CURRENT":
      if (mediaType === "ANIME") return `Watched Episode ${data.progress} of`;
      else return `Read Chapter ${data.progress} of`;
    case "PLANNING":
      if (mediaType === "ANIME") return `Planning to Watch`;
      else return `Planning to Read`;
    case "COMPLETED":
      return `Completed`;
    case "PAUSED":
      return `Paused`;
    case "DROPPED":
      return `Dropped`;
    case "REPEATING":
      if (mediaType === "ANIME") return `Re-watching`;
      else return `Re-reading`;
  }
}
